<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://dale-x-lee.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://dale-x-lee.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-05-18T08:51:06+00:00</updated><id>https://dale-x-lee.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">A Collection of Baker-Campbell-Hausdorff-Type formulas(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2025/A-Collection-of-Baker-Campbell-Hausdorff-Type-Formulas/" rel="alternate" type="text/html" title="A Collection of Baker-Campbell-Hausdorff-Type formulas(In Chinese)"/><published>2025-05-09T23:25:16+00:00</published><updated>2025-05-09T23:25:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2025/A-Collection-of-Baker-Campbell-Hausdorff-Type-Formulas</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2025/A-Collection-of-Baker-Campbell-Hausdorff-Type-Formulas/"><![CDATA[<p>在李群和李代数的理论中，一个比较重要的公式是Baker-Campbell-Hausdorff公式（BCH公式，也称Dynkin公式）：</p> <blockquote> <p><strong>定理</strong>：任给李群\(G\)，记它的李代数\(\mathfrak{g}\)，则存在\(\mathfrak{g}\)在\(0\)处的邻域\(U\)，使得对任意的\(X,Y \in U\)，有下面的等式：</p> \[\exp(X)\exp(Y) = \exp(Z)\] <p>其中\(Z\)可表示为关于\(X,Y\)的李括号和高阶李括号的无穷级数。具体而言，有：</p> \[\begin{aligned} Z &amp; = X+Y+\frac{1}{2}[X,Y]+\cdots \\ &amp; = X + Y + \sum_{k=1}^{+\infty} \frac{(-1)^k}{k+1} \sum \frac{(-1)^{\sum_i (l_i + m_i)}}{l_1 + \cdots + l_k + 1} \frac{(\operatorname{ad}_Y)^{l_1}}{l_1!} \circ \frac{(\operatorname{ad}_X)^{m_1}}{m_1!} \circ \cdots \circ \frac{(\operatorname{ad}_Y)^{l_k}}{l_k!} \circ \frac{(\operatorname{ad}_X)^{m_k}}{m_k!} (Y) \\ \end{aligned}\] <p>这里第二个求和号是对所有的整数\(l_1,\dots,l_k,m_1,\dots,m_k\geqslant 0, m_i+l_i &gt;0\)求和。</p> </blockquote> <p>BCH公式是一个相当一般的结果，但很多时候我们不需要用到这么强的结论，比如只需要给出一阶展开或者二阶展开就足够了，在这个时候，对应的结论也会有更简单的证明。在这篇笔记里，我们将这些更弱的结论称作Baker-Campbell-Hausdorff型(BCH型)的公式。而这篇笔记的目的就是记录一些BCH型的公式及其证明。</p> <p>这篇笔记里给出的公式都可以由BCH公式推出，但我们会给出独立于BCH公式的证明。对于BCH型的公式，一个相当诱人的证明方式是，将\(\exp(X)\)展开为无穷级数来计算（事实上，不少资料里，矩阵李群的BCH公式就是用这种办法证明的）。这一办法对于矩阵李群可行，但不适用于一般的李群。这篇笔记中展示的证明都是一般李群上的证明。</p> <hr/> <p>在开始之前，我们不加证明地给出一些基本的概念和结论。</p> <p>对一个李群\(G\)，我们用对应的哥特体小写字母\(\mathfrak{g}\)表示它的李代数，比如向量空间\(V\)上的线性变换群\(GL(V)\)的李代数为\(\mathfrak{gl}(V)\). 我们用\(\operatorname{Ad}\)表示\(G\)在\(\mathfrak{g}\)上的伴随作用：</p> \[\begin{aligned} \operatorname{Ad} \colon G &amp; \longrightarrow GL(\mathfrak{g}) \\ g &amp; \longmapsto \operatorname{Ad}_g \\ \end{aligned}\] <p>我们之后会用到的伴随作用\(\operatorname{Ad}\)的性质是</p> \[g\exp(X)g^{-1} = \exp(\operatorname{Ad}_gX),\; \forall g\in G, X\in\mathfrak{g}.\] <p>伴随作用的切映射给出的是\(\mathfrak{g}\)在\(\mathfrak{g}\)上的伴随作用</p> \[\operatorname{ad}\colon X \mapsto \operatorname{ad}_X.\] <p>根据指数映射的自然性，我们有\(\operatorname{Ad}_{\exp(X)} = e^{\operatorname{ad}_X}\)，也就是下面的交换图：</p> \[\begin{array}{rcl} G &amp; \longrightarrow &amp; GL(\mathfrak{g}) \\ \exp\uparrow &amp; &amp; \uparrow e^{A} \\ \mathfrak{g} &amp; \longrightarrow &amp; \mathfrak{gl}(\mathfrak{g}) \\ \end{array}\] <p>我们最后指出，\(\operatorname{ad}\)就是李括号，也就是</p> \[\operatorname{ad}_X Y = [X,Y],\quad \forall X,Y \in \mathfrak{g}.\] <p>下面进入到对具体公式的讨论。</p> <h2 id="expsxexptyexp-sx的展开">\(\exp(sX)\exp(tY)\exp(-sX)\)的展开</h2> <p>一个相当简单的例子是\(\exp(sX)\exp(tY)\exp(-sX)\)的展开。我们可以相当容易地给出任意阶展开：</p> \[\begin{aligned} \exp(sX)\exp(tY)\exp(-sX) &amp; = \exp\left(t(Y+s[X,Y]+\frac{s^2}{2}[X,[X,Y]]+\cdots)\right) \\ &amp; = \exp\left(t\sum_{n=0}^{\infty}\frac{s^n}{n!}(\operatorname{ad}_{X})^{n}Y\right) \\ \end{aligned}\] <hr/> <p>事实上，利用前面给出的基本性质，有</p> \[\begin{aligned} \exp(sX)\exp(tY)\exp(-sX) &amp; = \exp\left(\operatorname{Ad}_{\exp(sX)}(tY)\right)\\ &amp; = \exp\left(t\cdot e^{\operatorname{ad}_{sX}}Y\right)\\ &amp; = \exp\left(t\cdot\sum_{n=0}^{+\infty} \frac{s^n}{n!}(\operatorname{ad}_X)^{n}Y\right) \\ &amp; = \exp\left(t(Y+s[X,Y]+\frac{s^2}{2}[X,[X,Y]]+\cdots)\right) \\ \end{aligned}\] <p>上面的等式里，如果令\(s=t\)，还可以得到\(\exp(tX)\exp(tY)\exp(-tX)\)的二阶展开：</p> \[\exp(tX)\exp(tY)\exp(-tX)=\exp(tY+t^2[X,Y]+O(t^3)).\] <h2 id="exptxexpsyexp-txexp-sy的二阶展开">\(\exp(tX)\exp(sY)\exp(-tX)\exp(-sY)\)的二阶展开</h2> <p>另一个可能会碰到的例子是</p> \[\exp(tX)\exp(sY)\exp(-tX)\exp(-sY) = \exp(st[X,Y]+o(s^2+t^2))\] <p>如果在上面的公式里取\(s=t\)，就会得到</p> \[\exp(tX)\exp(tY)\exp(-tX)\exp(-tY) = \exp(t^2[X,Y]+o(t^2))\] <p>这说明李代数的李括号和李群的交换子是几乎对应的。</p> <hr/> <p>我们下面证明第一个公式。这可以靠计算</p> \[F(s,t) \colon= \exp^{-1}(\exp(tX)\exp(sY)\exp(-tX)\exp(-sY))\] <p>在\((0,0)\)处的前两阶偏导数得到。我们给出具体的计算。</p> <p>从\(F(s,t)\)的表达式可以看出的是</p> \[F(0,t)=F(s,0)=0 \in \mathfrak{g},\; \forall s,t\in \mathbb{R}\] <p>由此可以知道：</p> \[\begin{aligned} \frac{\partial F}{\partial t}(0,0) = \frac{\partial F}{\partial s}(0,0) = 0 \\ \frac{\partial^2 F}{\partial t^2}(0,0) = \frac{\partial^2 F}{\partial s^2}(0,0) = 0 \\ \end{aligned}\] <p>又有</p> \[\begin{aligned} \frac{\partial F}{\partial s}(0,t) &amp; = \frac{\mathrm{d}}{\mathrm{d}s}\Big\vert_{s=0} \exp^{-1}(\exp(tX)\exp(sY)\exp(-tX)\exp(-sY)) \\ &amp; = \frac{\mathrm{d}}{\mathrm{d}s}\Big\vert_{s=0} \exp^{-1}(\exp(s\cdot\operatorname{Ad}_{\exp(tX)}Y)\exp(-sY)) \\ &amp; = \exp^{-1}_{*}\big\vert_{e}\left(\operatorname{Ad}_{\exp(tX)}Y + (-Y)\right) \\ &amp; = \operatorname{Ad}_{\exp(tX)}Y -Y \\ \end{aligned}\] <p>所以再进一步对\(t\)求导可得：</p> \[\begin{aligned} \frac{\partial^2F}{\partial t\partial s}(0,0) &amp; = \frac{\mathrm{d}}{\mathrm{d}t}\Big\vert_{t=0}(\operatorname{Ad}_{\exp(tX)}Y - Y) \\ &amp; = \operatorname{ad}_X Y = [X,Y]. \end{aligned}\] <p>这样我们可以得到\(F(s,t)\)的二阶展开</p> \[\begin{aligned} F(s,t) = &amp; F(0,0)+\frac{\partial F}{\partial t}(0,0)\cdot t + \frac{\partial F}{\partial s}(0,0)\cdot s \\ &amp; + \frac{1}{2}\left(\frac{\partial^2 F}{\partial t^2}(0,0)\cdot t^2 +2 \frac{\partial^2 F}{\partial t\partial s}(0,0) \cdot st + \frac{\partial^2 F}{\partial s^2}(0,0)\cdot s^2\right) \\ &amp; + o(s^2+t^2) \\ = &amp; st [X,Y] + o(s^2+t^2) \\ \end{aligned}\] <p>在上面等式的两边作用指数映射，就得到了这一节开头的公式。</p> <h2 id="exptxexpsy的二阶展开">\(\exp(tX)\exp(sY)\)的二阶展开</h2> <p>我们在这一节里给出\(\exp(tX)\exp(tY)\)的二阶展开：</p> \[\exp(tX)\exp(sY) = \exp\left(tX+sY+\frac{st}{2}[X,Y] + o(s^2+t^2)\right).\] <p>如果取\(s=t\)，则有</p> \[\exp(tX)\exp(tY) = \exp\left(t(X+Y)+\frac{t^2}{2}[X,Y] + o(t^2)\right).\] <p>此外，我们还有更一般的公式</p> \[\exp(t_1X_1)\exp(t_2X_2)\cdots\exp(t_nX_n) = \exp\left(\sum_{i=1}^{n}t_iX_i + \frac{1}{2}\sum_{1\leqslant i&lt;j\leqslant n}t_it_j[X_i,X_j] + o(\sum_{i=1}^{n}t_i^2)\right)\] <p>这两个公式的证明相对于前两个公式而言，要困难许多。这里的证明参考的是王作勤老师的<a href="http://staff.ustc.edu.cn/%7Ewangzuoq/Courses/13F-Lie/Notes/Lec%2008-09.pdf">笔记</a>。一般的李群的BCH公式的证明也可以在这篇笔记中找到。</p> <hr/> <p>对李群上的左不变向量场\(X\in\mathfrak{g}\)，它生成的\(G\)上的流为</p> \[\Phi_t(g) = g\cdot \exp(tX)\] <p>所以说</p> \[\frac{\mathrm{d}}{\mathrm{d}t}\Big\vert_{t=0}f(g\cdot \exp(tX)) = \frac{\mathrm{d}}{\mathrm{d}t}\Big\vert_{t=0}f(\Phi_t(g)) = (Xf)(g)\] <p>更进一步，对任意的\(t\)，有</p> \[\begin{aligned} \frac{\mathrm{d}}{\mathrm{d}t}f(g\cdot \exp(tX)) &amp; = \frac{\mathrm{d}}{\mathrm{d}s}\Big\vert_{s=0}f(g\cdot \exp((s+t)X)) \\ &amp; = \frac{\mathrm{d}}{\mathrm{d}s}\Big\vert_{s=0} f(g\cdot\exp(tX)\exp(sX)) \\ &amp; = (Xf)(g\cdot\exp(tX)) \\ \end{aligned}\] <p>基于上式，由归纳法可以得到：对任意的\(k\geqslant 0\)，有</p> \[\frac{\mathrm{d}^k}{\mathrm{d}t^k}f(g\cdot\exp(tX)) = (X^kf)(g\cdot\exp(tX))\] <p>特别的，在\(t=0\)处有</p> \[\frac{\mathrm{d}^k}{\mathrm{d}t^k}\Big\vert_{t=0}f(g\cdot\exp(tX)) = (X^{k}f)(g).\] <p>上面的等式可以推广到多个向量场的情形。对两个左不变向量场\(X_1,X_2\in\mathfrak{g}\)以及\(k_1,k_2\geqslant 0\)，有</p> \[\begin{aligned} \frac{\partial^{k_1+k_2}}{\partial t_1^{k_1}\partial t_2^{k_2}}\Big\vert_{(0,0)}f(g\cdot\exp(t_1X_1)\exp(t_2X_2)) &amp; = \frac{\mathrm{d}^{k_1}}{\mathrm{d}t_2^{k_1}}\Big\vert_{t_1=0}\left(\frac{\mathrm{d}^{k_2}}{\mathrm{d}t_2^{k_2}}\Big\vert_{t_2=0}f(g\cdot\exp(t_1X_1)\exp(t_2X_2))\right) \\ &amp; =\frac{\mathrm{d}^{k_1}}{\mathrm{d}t_1^{k_1}}\Big\vert_{t_1=0}(X_2^{k_2}f)(g\cdot\exp(t_1X_1)) \\ &amp; = (X_1^{k_1}X_2^{k_2}f)(g) \end{aligned}\] <p>更一般地，有</p> \[\frac{\partial^{k_1+\cdots+k_n}}{\partial t_1^{k_1}\cdots\partial t_n^{k_n}}\Big\vert_{(0,\dots,0)}f(g\cdot\exp(t_1X_1)\cdots\exp(t_nX_n)) = (X_1^{k_1}\cdots X_n^{k_n}f)(g)\] <p>使用上面的等式就可以给出\(f(\exp(t_1X_1)\cdots\exp(t_mX_m))\)的泰勒展开：</p> <blockquote> <p><strong>结论</strong>：对任意的光滑函数\(f \colon G \rightarrow \mathbb{R}^k\)，有</p> \[f(\exp(t_1X_1)\cdots\exp(t_nX_n)) = \sum_{k_1+\cdots+k_n\leqslant N} \frac{t_1^{k_1}\cdots t_n^{k_n}}{k_1!\cdots k_n!}(X_1^{k_1}\cdots X_n^{k_n}f)(e) + O((t_1^{2}+\cdots+t_n^{2})^{\frac{N+1}{2}})\] </blockquote> <p>我们后面只关心二阶的展开：</p> \[\begin{aligned} f(&amp;\exp(t_1X_1)\cdots\exp(t_nX_n)) \\ &amp; = f(e)+ \sum_{i=1}^{n}t_i(X_if)(e) + \frac{1}{2}\sum_{i=1}^{n} t_i^2(X_i^2f)(e) + \sum_{1\leqslant i &lt; j \leqslant n}t_it_j(X_iX_jf)(e) + O((t_1^2+\cdots+t_n^2)^{\frac{3}{2}}) \\ &amp; = f(e)+ \sum_{i=1}^{n}t_i(X_if)(e) + \frac{1}{2}\left((\sum_{i=1}^{n} t_iX_i)^2f\right)(e) + \frac{1}{2}\sum_{1\leqslant i &lt; j \leqslant n}t_it_j([X_i,X_j]f)(e) + O((t_1^2+\cdots+t_n^2)^{\frac{3}{2}}) \\ \end{aligned}\] <p>在上面的式子里，取\(f = \exp^{-1}\colon G\rightarrow \mathfrak{g}\)，可以算出，对任意的\(X\in\mathfrak{g}\)，有</p> \[\begin{aligned} (X\exp^{-1})(e) &amp; = \frac{\mathrm{d}}{\mathrm{d}t}\Big\vert_{t=0} \exp^{-1}(\exp(tX)) = \frac{\mathrm{d}}{\mathrm{d}t}\Big\vert_{t=0} tX = X, \\ (X^{2}\exp^{-1})(e) &amp; = \frac{\mathrm{d}^2}{\mathrm{d}t^2}\Big\vert_{t=0} \exp^{-1}(\exp(tX)) = \frac{\mathrm{d}^2}{\mathrm{d}t^2}\Big\vert_{t=0} tX = 0. \end{aligned}\] <p>所以上面的展开式会给出：</p> \[\exp^{-1}(\exp(t_1X_1)\cdots\exp(t_nX_n)) = \sum_{i=1}^{n}t_iX_i + \frac{1}{2}\sum_{1\leqslant i &lt; j \leqslant n} t_it_j [X_i,X_j] + O((t_1^2+\cdots+t_n^2)^{\frac{3}{2}}).\] <p>也就是</p> \[\exp(t_1X_1)\cdots\exp(t_nX_n) = \exp\left(\sum_{i=1}^{n}t_iX_i + \frac{1}{2}\sum_{1\leqslant i &lt; j \leqslant n} t_it_j [X_i,X_j] + O((t_1^2+\cdots+t_n^2)^{\frac{3}{2}})\right).\] <p>而这正是我们前面想要证明的公式。</p>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[A collection of formulas similar to Baker-Campbell-Hausdorff formula and their proofs (which are simpler than that of BCH formula).]]></summary></entry><entry><title type="html">Heat Equation and Path Integral From Stochastic Point of View(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2025/Heat-Equation-From-Stochastic-Point-of-View/" rel="alternate" type="text/html" title="Heat Equation and Path Integral From Stochastic Point of View(In Chinese)"/><published>2025-03-13T21:45:16+00:00</published><updated>2025-03-13T21:45:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2025/Heat-Equation-From-Stochastic-Point-of-View</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2025/Heat-Equation-From-Stochastic-Point-of-View/"><![CDATA[]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[We show the relation between the Brownian motion and heat equation, and we give a path integral interpretation of a solution of heat equation.]]></summary></entry><entry><title type="html">Existence of Almost Complex Structure on Spheres(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2025/Existence-of-Almost-Complex-Structure-on-Spheres/" rel="alternate" type="text/html" title="Existence of Almost Complex Structure on Spheres(In Chinese)"/><published>2025-03-13T21:42:16+00:00</published><updated>2025-03-13T21:42:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2025/Existence-of-Almost-Complex-Structure-on-Spheres</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2025/Existence-of-Almost-Complex-Structure-on-Spheres/"><![CDATA[]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[This note records the proof that there is no almost complex structure on sphere unless its dimension is 2 or 6.]]></summary></entry><entry><title type="html">Notes on Feynman Integral and Feynman Diagram(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2025/Note-on-Feynman-Integral-and-Feynman-Diagram/" rel="alternate" type="text/html" title="Notes on Feynman Integral and Feynman Diagram(In Chinese)"/><published>2025-02-23T21:05:16+00:00</published><updated>2025-02-23T21:05:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2025/Note-on-Feynman-Integral-and-Feynman-Diagram</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2025/Note-on-Feynman-Integral-and-Feynman-Diagram/"><![CDATA[]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[A note on the deductions of the path integral and the Feynman diagram.]]></summary></entry><entry><title type="html">Compact Lie Groups as Boundaries of Manifolds(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2025/Compact-Lie-Groups-as-Boundaries-of-Manifolds/" rel="alternate" type="text/html" title="Compact Lie Groups as Boundaries of Manifolds(In Chinese)"/><published>2025-01-26T00:58:16+00:00</published><updated>2025-01-26T00:58:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2025/Compact-Lie-Groups-as-Boundaries-of-Manifolds</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2025/Compact-Lie-Groups-as-Boundaries-of-Manifolds/"><![CDATA[<p>我们在这篇笔记里给出一个简单的构造：对任意一个紧李群\(G\)，我们给出一个具体的带边紧流形\(M\)，使得它的边界\(\partial M\)微分同胚于\(G\).</p> <h2 id="流形的构造">流形的构造</h2> <p>我们不加证明地使用下面的结果：</p> <blockquote> <p><strong>结论</strong>：对任意一个紧流形\(G\)，存在\(G\)真李子群\(H\)，使得</p> \[H \cong S^1\] <p>这里\(S^1\subset \mathbb{C}\)上的运算由\(\mathbb{C}\)上乘法诱导。</p> </blockquote> <p>我们这里不区分\(H\)和\(S^1\)，这样\(S^1\)在\(G\)上的右乘给出了\(G\)上的紧、自由\(S^1\)-右作用，这使得\(G\)成为了\(G/S^1\)上一个\(S^1\)-主丛：</p> \[\begin{matrix} S^1 &amp; \hookrightarrow &amp; G \\ &amp;&amp; \downarrow \\ &amp;&amp; G/S^1 \\ \end{matrix}\] <p>取\(S^1\)在\(\mathbb{C}\)上的表示\(\rho(e^{i\theta})z = e^{i\theta}z\). 这一表示定义了配从</p> \[E = G\times_{\rho} \mathbb{C} = \{[(g, z)]\mid g\in G, z\in \mathbb{C}\}\] <p>注意到\(\mathbb{C}\)上的标准内积是\(S^1\)-不变的，所以它诱导了向量丛\(E\)上的内积\(g(u,v)\)，于是可以得到\(E\)的单位球丛</p> \[B(E)= \{v\in E \mid g(v,v)\leqslant 1\} =\{[(g,z)]\in E \mid |z| \leqslant 1\}\] <p>其中最后一个等号用到了\(g\)的定义。我们说明\(B(E)\)的边界正好是\(G\).</p> <p>事实上，我们有</p> \[\begin{aligned} \partial \bigl(B(E)\bigr) &amp; = \{v\in E \mid g(v,v)=1\} \\ &amp; = \{[(g,z)]\mid z\in S^1\} \\ &amp; = G \times_{\rho}S^1 \end{aligned}\] <p>而容易看出\(G \times_{\rho} S^1\)和\(G\)微分同胚的（例如可由\(S^1\)-等变映射</p> \[\begin{matrix} m \colon &amp; G \times S^1 &amp; \longrightarrow &amp; G \\ &amp; (g,z) &amp; \longmapsto &amp; g\cdot z \\ \end{matrix}\] <p>诱导光滑映射</p> \[\begin{matrix} \tilde{m} \colon &amp; \partial \bigl(B(E)\bigr) &amp;\longrightarrow &amp; G \\ &amp; [(g,z)] &amp; \longmapsto &amp; g\cdot z \\ \end{matrix}\] <p>然后靠证明\(\tilde{m}\)的单的和切映射处处是线性同构来说明）。这样我们就完成了构造。</p> <h2 id="一个例子作为流形边界的三维实射影空间">一个例子：作为流形边界的三维实射影空间</h2> <p>对四元数\(\mathbb{H}\)上的球面</p> \[S^3 = \{x + yi+zj+wk \mid x^2+y^2+z^2+w^2=1\}\] <p>容易看出它在四元数乘法下封闭，并且可以证明，它可以保持内积地作用在</p> \[$\mathbb{R}^3=\{ui+vj+wk\mid u,v,w\in\mathbb{R}\}\] <p>上：</p> \[\alpha \cdot r := \alpha r \alpha^{-1},\quad \forall \alpha \in S^3, r\in \mathbb{R}^3\] <p>因此我们会得到李群同态：</p> \[S^3 \longrightarrow SO(3)\] <p>这一同态的核恰好为\(\pm 1\)，所以我们会有微分同胚：</p> \[\mathbb{R}P^3 \cong S^3/\{\pm 1\} \cong SO(3)\] <p>这样三维实射影空间\(\mathbb{R}P^3\)会是某个流形的边界。我们在这里给出一个更加具体的构造。</p> <p>我们取\(S^2\)的切空间</p> \[TS^3 = \{(x,v)\mid x,v\in\mathbb{R}^3, x\cdot x = 1, x\cdot v = 0\}\] <p>它的单位球丛是：</p> \[N = \{(x,v) \in \mathbb{R}^3\times \mathbb{R}^3 \mid x\cdot v = 0, x\cdot x = 1, v\cdot v \leqslant 1\}\] <p>这时有：</p> \[\mathbb{R}P^3 \cong \partial N\] <p>事实上，这个同胚可由下面的的映射给出：</p> \[\partial N \ni (x,v) \longmapsto (x,v,x\times v) \in SO(3) \cong \mathbb{R}P^3\] <p>其中我们将\(\mathbb{R}^3\)中元素视为列向量，\(x\times v\)表示两个向量的叉乘。</p>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[A constructive proof that every Lie group is the boundary of certain smooth manifold.]]></summary></entry><entry><title type="html">Three Counterexamples About Mayer-Vietoris Sequence(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2025/Three-Counterexamples-About-M-V-Sequences/" rel="alternate" type="text/html" title="Three Counterexamples About Mayer-Vietoris Sequence(In Chinese)"/><published>2025-01-25T22:30:16+00:00</published><updated>2025-01-25T22:30:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2025/Three-Counterexamples-About-M-V-Sequences</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2025/Three-Counterexamples-About-M-V-Sequences/"><![CDATA[]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[When certain conditions are removed, there are examples where the Mayer-Vietoris sequence does not hold, where the excision theorem does not hold and where the homology groups of a pair of spaces is not isomorphic to that of the quotient space.]]></summary></entry><entry><title type="html">Notes on Spectral Sequence, Double Complex, Derived Functor and Universal Coefficient Theorem(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2024/Spectral-Sequence-Double-Complex-and-Universal-Coefficient-Theorem/" rel="alternate" type="text/html" title="Notes on Spectral Sequence, Double Complex, Derived Functor and Universal Coefficient Theorem(In Chinese)"/><published>2024-12-26T11:30:16+00:00</published><updated>2024-12-26T11:30:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2024/Spectral-Sequence-Double-Complex-and-Universal-Coefficient-Theorem</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2024/Spectral-Sequence-Double-Complex-and-Universal-Coefficient-Theorem/"><![CDATA[]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[Prove some results related to derived functors and universal coefficient theorem using spectral sequences.]]></summary></entry><entry><title type="html">Proof of the Hodge Decomposition on Riemannian Manifolds(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2024/Proof-of-Hodge-Decomposition/" rel="alternate" type="text/html" title="Proof of the Hodge Decomposition on Riemannian Manifolds(In Chinese)"/><published>2024-11-19T00:01:16+00:00</published><updated>2024-11-19T00:01:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2024/Proof-of-Hodge-Decomposition</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2024/Proof-of-Hodge-Decomposition/"><![CDATA[]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[This note records a proof of Hodge decomposition on Riemannian manifolds. We view the Laplacian as the square of a Dirac operator, which is unbounded and self-adjoint. And we prove the theorem by showing that its "inverse" is compact.]]></summary></entry><entry><title type="html">Deduction of Morse Inequality, Perfect Morse Function and Decomposition into Derict Sum(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2024/Deduction-of-Morse-Inequality-Perfect-Morse-Function-and-Decomposition-into-Derict-Sum/" rel="alternate" type="text/html" title="Deduction of Morse Inequality, Perfect Morse Function and Decomposition into Derict Sum(In Chinese)"/><published>2024-10-20T14:30:16+00:00</published><updated>2024-10-20T14:30:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2024/Deduction-of-Morse-Inequality-Perfect-Morse-Function-and-Decomposition-into-Derict-Sum</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2024/Deduction-of-Morse-Inequality-Perfect-Morse-Function-and-Decomposition-into-Derict-Sum/"><![CDATA[<h2 id="摘要">摘要</h2> <p>本文会给出Morse-Bott函数对应的Morse不等式的推导，并由此从代数的角度给出一个Morse-Bott函数是完美的(perfect)的充要条件。我们在推导中假定，下水平集在越过临界点时拓扑上的变化是已经熟知的结论。</p> <h2 id="定义与主定理">定义与主定理</h2> <p>Morse理论的大致想法是：通过空间\(M\)上一个“足够好”的函数\(f\)（这样的函数通常被叫做Morse-Bott函数）的临界点来描述空间\(M\)本身的拓扑性质。具体来说，Morse理论中的空间指的是紧致微分流形；一个函数\(f\)需要满足下面两点才能被叫做“足够好”：</p> <ul> <li>函数\(f\)的临界点集\(C_f\)的每个连通分支\(C_i\)都是一个子流形。</li> <li>函数\(f\)在任意一个临界点\(p \in C_i\)处的“Hessian矩阵”限制在\(C_i\)的法丛上非退化。</li> </ul> <p>我们再引入一些定义。</p> <p>对临界点集的每个联通分支\(C_i\)，将\(f\)在\(C_i\)上的Hessian矩阵的负惯性指数称为\(C_i\)的指标，一般用\(\lambda_{C_i}\)来表示。更进一步，在选定了一个黎曼度量之后，可以定义出\(C_i\)的法丛\(\nu_{C_i}\)，根据\(f\)的Hessian矩阵的特征值的正负，我们可以将法丛\(\nu_{C_i}\)进一步分解成两部分：</p> \[\nu_{C_i} = \nu_{C_i}^+ \oplus \nu_{C_i}^-\] <p>并用\(\theta^{\pm}\)表示由\(\nu_{C_i}^{\pm}\)的定向给出的纤维丛。</p> <p>对于任意一个拓扑空间\(X\)和主理想整环\(R\)，我们可以定义一个无穷形式幂级数\(P_t(X; R) \in \mathbb{Z}[[t]]\)，它的\(k\)次项系数正好是第\(k\)个\(R\)系数约化奇异上同调群关于\(R\)的秩，也就是</p> \[P_t(X; R) = \sum_{k \geq 0}\mathrm{rank}_R\left(H^k(X; R)\right)\cdot t^k\] <p>这个多项式被称作空间\(X\)的Poincaré多项式。我们后面只会使用到\(R\)为整数环\(\mathbb{Z}\)或\(\mathbb{Q}\)的某个扩域的情形。在不引发歧义的情况下，我们会将Poincaré多项式简记为\(P_t(X)\). 在此基础上，我们可以定义一个Morse-Bott函数\(f\)的Morse多项式</p> \[\mathfrak{M}_t(f; R) := \sum_{C_i} t^{\lambda_{C_i}}P_t(C_i; \theta^-\otimes R)\] <p>这里的求和是对临界点集\(C_f\)的全体连通分支\(C_i\)求和。</p> <p>在这些定义的基础上，我们可以陈述Morse理论的一个主要结果：</p> <blockquote> <p>对紧致流形\(M\)和其上的Morse-Bott函数\(f\)，如果设\(f\)的临界点的连通分支为\(C_1, C_2, \dots, C_N\)，那么存在一个以非负整数为系数的无穷形式幂级数\(R(t)\)，使得\(f\)的Morse多项式和\(M\)的Poincaré多项式的差正好是\((1+t)R(t)\)，也就是</p> \[\mathfrak{M}_t(f;R)-P_t(M; R) = (1+t)R(t)\] <p>这里\(R\)是整数环\(\mathbb{Z}\)或有理数域\(\mathbb{Q}\)的扩域。</p> </blockquote> <p>这被称作Morse不等式，是本文的主定理。</p> <h2 id="主定理的证明">主定理的证明</h2> <p>为了后面叙述的方便，我们再引入一些定义。</p> <p>对于一个函数\(f: M \rightarrow \mathbb{R}\)，将集合\(f^{-1}(-\infty, a)\)称作\(f\)的下水平集，记作\(M^a\).</p> <p>我们的证明需要用到下面的引理：</p> <blockquote> <p>对紧致流形\(M\)和其上的Morse-Bott函数\(f\)：</p> <p>(1)如果\(f\)在\([a, b]\)中无临界值，那么\(M^b\)与\(M^a\)同伦等价。</p> <p>(2) 如果\(f\)在区间\([a, b]\)的临界值只有\(c_0 \in (a, b)\)，设\(C\)是取值为\(c_0\)的那些临界点，那么有空间的同伦等价：</p> \[M^b \sim M^a \cup_{\phi} \nu_{C}^-\] <p>这里\(\phi: \partial \nu_{C}^- \rightarrow M^a\)是一个光滑映射。</p> </blockquote> <p>我们略去引理的证明。</p> <p>因为流形是紧致的，所以我们可以构造一列下水平集</p> \[\emptyset \subset \cdots \subset M^{a} \subset M^{b} \subset M^c \subset \cdots \subset M\] <p>使得任何两个相邻下水平集之间只有一个\(f\)的临界值。我们希望对这一列下水平集归纳地证明</p> \[\mathfrak{M}_t(f\vert _{M^a};R)-P_t(M^a; R) = (1+t)R_a(t)\] <p>其中\(f\vert _{M^a}\)表示\(f\)在\(M^a\)上的限制。归纳的奠基是容易的，我们主要看如何从\(M^a\)上的等式到\(M^b\)上的等式。</p> <p>对两个相邻的下水平集\(M^a \subset M^b\)，设其间的临界点集为\(C\). 通过对\(f\)作微扰，我们可以不妨假定\(C\)是连通的。为了展示证明的主要想法，我们进一步假设\(\nu_C^-\)是可定向向量丛。这一节最后的注记解释了处理不可定向的情况的方法。</p> <p>首先，空间对\((M^b, M^a)\)诱导了长正合列：</p> \[\cdots \xrightarrow{\delta^*_{k-1}} H^k(M^b, M^a) \xrightarrow{q^*_k} H^k(M^b) \xrightarrow{i^*_k} H^k(M^a) \xrightarrow{\delta^*_k} \cdots\] <p>利用引理以及Thom同构，我们知道\(H^k(M^b, M^a)\)和\(H^{k-\lambda_C}(C)\)同构。因此上面的长正合列变成了：</p> \[\cdots \xrightarrow{\delta^*_{k-1}} H^{k - \lambda_C}(C) \xrightarrow{q^*_k} H^k(M^b) \xrightarrow{i^*_k} H^k(M^a) \xrightarrow{\delta^*_k} \cdots\] <p>我们来看长正合列中的每个映射，它们给出了一系列短正合列：</p> \[0 \rightarrow \ker i^*_k \rightarrow H^k(M^b) \rightarrow \mathrm{im}\ i^*_k \rightarrow 0\] \[0 \rightarrow \ker q^*_k \rightarrow H^{k-\lambda_C}(C) \rightarrow \mathrm{im}\ q^*_k \rightarrow 0\] \[0 \rightarrow \ker \delta^*_k \rightarrow H^k(M^a) \rightarrow \mathrm{im}\ \delta^*_k \rightarrow 0 \\\] <p>进而可以得到等式：</p> \[\begin{matrix} \mathrm{rank}\left(\ker i^*_k \right) + \mathrm{rank}\left(\mathrm{im}\ i^*_k \right) &amp;=&amp; \mathrm{rank}\left(H^k(M^b) \right) \\ \mathrm{rank}\left(H^{k-\lambda_C}(C) \right) &amp;=&amp;\mathrm{rank}\left(\ker q^*_k \right) + \mathrm{rank}\left(\mathrm{im}\ q^*_k\right) \\ \mathrm{rank}\left(H^k(M^a) \right) &amp;=&amp; \mathrm{rank}\left(\ker \delta^*_k \right) + \mathrm{rank}\left(\mathrm{im}\ \delta^*_k \right) \\ \end{matrix}\] <p>将上面三个等式相加，并利用长正合列将所有的“\(\ker\)”都替换为“\(\mathrm{im}\)”后得到：</p> \[\begin{aligned} &amp;\mathrm{rank}\left(H^{k - \lambda_C}(C) \right) - \Bigl(\mathrm{rank}\left(H^k(M^b) \right) - \mathrm{rank}\left(H^k(M^a) \right) \Bigr) \\ &amp; =\mathrm{rank}\left(\mathrm{im}\ \delta^*_{k-1} \right) + \mathrm{rank}\left(\mathrm{im}\ \delta^*_k \right) \end{aligned}\] <p>在上面的等式两边同时乘以\(t^k\)，并对\(k\)求和就得到：</p> \[t^{\lambda_C} P_t(C)-\left(P_t(M^b) - P_t(M^a)\right) = (1+t)R_C(t)\] <p>其中\(R_C(t) = \sum_{k \geq 0} t^k \mathrm{rank}\left(\mathrm{im}\ \delta^*_k \right)\)是一个非负整数系数的形式幂级数。因为\(C\)是\(M^a\)与\(M^b\)之间唯一的临界点集，所以\(t^{\lambda_C}P_t(C)\)就是\(f\vert _{M^b}\)的Morse多项式和\(f\vert _{M^a}\)的Morse多项式的差，进而上面的等式可以写成</p> \[\begin{aligned} &amp;\mathfrak{M}_t(f\vert _{M^b};R)-P_t(M^b; R)\\ &amp; = \bigl(\mathfrak{M}_t(f\vert _{M^a};R)-P_t(M^a; R)\bigr) + (1+t)R_C(t)\\ \end{aligned}\] <p>利用这一等式，我们可以很轻松地完成归纳。</p> <h3 id="注记">注记</h3> <p>有读者会注意到，我们在定义Morse多项式时，用到了向量丛\(\nu_C^-\)的定向丛\(\theta^-\)，但证明中却没有出现这一纤维丛，这是因为我们在证明中假定了向量丛\(\nu_C^-\)是可定向的。在不可定向的时候，我们需要用到twisted-Thom同构：</p> \[H^*(\nu_C^-, \partial \nu_C^-; R) \cong H^{* - \lambda_C}(C; \theta^- \otimes R)\] <p>这时候就会出现\(\nu_C^-\)的定向丛\(\theta^-\).</p> <p>在系数环\(R\)是实数域\(\mathbb{R}\)的时候，可以在Bott和Tu所著的书<em>Differential Forms in Algebraic Topology</em>中第一章最后一节找到这一同构的证明。</p> <h2 id="完美morse函数">完美Morse函数</h2> <p>我们称一个Morse-Bott函数\(f: M \rightarrow \mathbb{R}\)是完美的(perfect)，如果它的Morse多项式正好等于\(M\)的Poincaré多项式。</p> <p>根据上面的证明，我们知道，一个Morse-Bott函数\(f\)是完美的当且仅当对每个临界点集\(C\)，我们定义的多项式\(R_C(t)\)等于0. 这可以总结为下面的结论：</p> <blockquote> <p>以下几个命题彼此等价：</p> <p>(1)一个函数\(f: M \rightarrow \mathbb{R}\)是完美的Morse-Bott函数</p> <p>(2)对临界点集的每个连通分支\(C\)和长正合列</p> \[\cdots \xrightarrow{\delta^*_{k-1}} H^{k - \lambda_C}(C) \xrightarrow{q^*_k} H^k(M^b) \xrightarrow{i^*_k} H^k(M^a) \xrightarrow{\delta^*_k} \cdots\] <p>中的映射\(\delta^*_k\)，有\(\mathrm{rank}\left(\mathrm{im}\ \delta^*_k \right) = 0\).</p> <p>(3)对每个\(k\)，上面长正合列中的映射\(\delta^*_k\)的像集由挠元素构成。</p> </blockquote> <p>当上同调的系数环被选取为有理数域\(\mathbb{Q}\)或者它的扩域时，上同调环始终是无挠的，所以我们得到了：</p> <blockquote> <p>在有理数域的扩域中，以下结论彼此等价：</p> <p>(1)一个函数\(f: M \rightarrow \mathbb{R}\)是完美的Morse-Bott函数</p> <p>(2)对临界点集的每个连通分支\(C\)和长正合列</p> \[\cdots \xrightarrow{\delta^*_{k-1}} H^{k - \lambda_C}(C) \xrightarrow{q^*_k} H^k(M^b) \xrightarrow{i^*_k} H^k(M^a) \xrightarrow{\delta^*_k} \cdots\] <p>中的每个映射\(\delta^*_k\)，它的像是\(0\).</p> <p>(3)上面的长正合列可以分裂为短正合列</p> \[0 \rightarrow H^{*-\lambda_C}(C) \xrightarrow{q^*} H^*(M^b) \xrightarrow{i^*} H^*(M^a) \rightarrow 0\] </blockquote> <p>注意到域系数的短正合列一定是分裂的，所以如果一个Morse函数\(f\)是完美的，下水平集每跨过一个临界点的一个连通分支，我们就能得到一个直和分解</p> \[H^*(M^b) \cong H^{*-\lambda_C}(C)\oplus H^*(M^a)\] <p>进而可以知道，我们有直和分解：</p> \[H^*(M) \cong \bigoplus_{C_i} H^{*-\lambda_{C_i}}(C_i)\] <p>这个等式相当于说，一个流形上的完美的Morse-Bott函数的临界点集几乎确定了这个流形的域系数上同调群。这里使用“几乎”是因为，上面的同构并不是典范的，这个同构依赖于归纳过程中将\(M^a\)的上同调群嵌入到\(M^b\)的上同调群的方式。</p>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[Some notes when learning Morse theory for the second time.]]></summary></entry><entry><title type="html">Simplex Decomposition of Product of Singular Simplexes(In Chinese)</title><link href="https://dale-x-lee.github.io/blog/2024/Simplex-Decomposition-of-Product-of-Singular-Simplexes/" rel="alternate" type="text/html" title="Simplex Decomposition of Product of Singular Simplexes(In Chinese)"/><published>2024-10-17T23:57:16+00:00</published><updated>2024-10-17T23:57:16+00:00</updated><id>https://dale-x-lee.github.io/blog/2024/Simplex-Decomposition-of-Product-of-Singular-Simplexes</id><content type="html" xml:base="https://dale-x-lee.github.io/blog/2024/Simplex-Decomposition-of-Product-of-Singular-Simplexes/"><![CDATA[<h2 id="1引入">1.引入</h2> <p>在同调论里，一个很自然的问题是，对于两个拓扑空间\(X,Y\)，它们的乘积\(X\times Y\)的奇异同调群如何用各自的奇异同调群表示。</p> <p>这一问题相当基本，答案看起来也相当明显：我们希望有</p> \[H_*(X\times Y) \cong H_*(X)\otimes H_*(Y).\] <p>不过在试图计算的时候，得到上面的关系会相当麻烦。一个主要的原因是，两个奇异单形的乘积不再是奇异单形。</p> <p>为了让我们的计算能够进行下去，一个办法就是对两个奇异单形\(\sigma, \tau\)的乘积\(\sigma \times \tau\)作单形剖分。依据Gelfand的<em>Methods of Homoligical Algebra</em>，我们这里提供一个剖分的办法（但不会给出证明）。</p> <h2 id="2一些记号">2.一些记号</h2> <p>我们在这一节里介绍之后使用的符号。</p> <ul> <li>\(e_{i-1}\)：\(\mathbb{R}^n(n\geq i)\)中的基向量，也就是第\(i\)个分量为\(1\)，余下分量为\(0\)的向量。因为在每个向量末尾添上\(0\)，可以将\(\mathbb{R}^n\)自然地嵌入到\(\mathbb{R}^{n+1}\)，所以我们后面认为\(e_i\)落在一个维数充分大的向量空间里。</li> <li>\(\Delta^q\)：\(q\)维标准单形，即</li> </ul> \[\{ \sum_{i=0}^q x_i e_i \mid 0\leqslant x_i \leqslant 1, \sum_{i}x_i =1 \}\] <ul> <li>\(\sigma\colon \Delta^p \rightarrow X\)：这是\(X\)中的一个奇异单形，有时我们会用上标来表示\(\sigma\)的维数，即\(\sigma^p\)表明\(\sigma\)是一个\(p\)维单形。</li> <li>\([v_0,v_1, \dots, v_q], v_i \in V\)：表示线性空间\(V\)中的奇异单形：</li> </ul> \[\begin{aligned} \Delta^q &amp; \longrightarrow V \\ \sum_{i=0}^q x_ie_i &amp; \longmapsto \sum_{i=0}^q x_i v_i \end{aligned}\] <ul> <li>\([n]\)：表示集合\(\{0,1,2,\dots, n\}\).</li> </ul> <h2 id="3奇异单形的乘积的单形剖分">3.奇异单形的乘积的单形剖分</h2> <p>我们接下来描述两个奇异单形\(\sigma: \Delta^p \rightarrow X,\tau: \Delta^q \rightarrow Y\)的乘积：</p> \[\sigma \times \tau \colon \Delta^p \times \Delta^q \longrightarrow X \times Y\] <p>的单形剖分：</p> \[m(\sigma, \tau) \in S_{p+q}(X\times Y)\] <h3 id="表格里的路径">表格里的路径</h3> <p>我们将集合\([p]\times [q]\)看作一个\(p\)列、\(q\)行的表格的顶点，每个顶点的横坐标的取值范围为\(0,1,\dots, p\)，纵坐标的取值范围为\(0,1,\dots, q\). 并且表格左下角的顶点为\((0,0)\)，右上角的顶点为\((p,q)\).</p> \[\begin{array}{|l|l|l|l|l|l|} \hline \ &amp; \ &amp; \ &amp; \cdots &amp; \ &amp; \ \\ \hline \ &amp; \ &amp; \ &amp; \cdots &amp; \ &amp; \ \\ \hline \ &amp; \ &amp; \ &amp; \cdots &amp; \ &amp; \ \\ \hline \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots\\ \hline \ &amp; \ &amp; \ &amp; \cdots &amp; \ &amp; \ \\ \hline \end{array}\] <p>我们从\((0,0)\)出发，每次向上或者向右走一格，一直走到顶点\((p,q)\)，就会得到这个表格中的路径。严格来说，表格里的路径是一个映射：</p> \[\begin{aligned} \gamma\colon [p+q] &amp; \longrightarrow [p]\times [q]. \\ i &amp; \longmapsto \bigl(x(i),y(i)\bigr) \end{aligned}\] <p>满足：</p> \[\begin{gathered} \gamma(0)=(0,0), \ \gamma(p+q)=(p,q)\\ \gamma(i)-\gamma(i-1) \in \{(0,1), (1,0)\}, \forall 1\leqslant i \leqslant p+q.\\ \end{gathered}\] <p>我们将位于\(\gamma\)下方的方格的个数记为\(\operatorname{ind}\gamma\)，将\((-1)^{\operatorname{ind}\gamma}\)称为\(\gamma\)的符号，记为\(\operatorname{sgn}\gamma\). 如果将\(\gamma\)视为映射的话，有</p> \[\operatorname{sgn}\gamma = (-1)^{\frac{q(q-1)}{2} + \sum_{i=1}^{p+q-1}y(i)}\] <h3 id="单纯形剖分">单纯形剖分</h3> <p>借助表格里的道路，我们可以定义两个奇异单形的乘积的单形剖分：</p> \[m(\sigma^{p}, \tau^{q}) = \sum_{\gamma \in \mathscr{P}(p,q)} \operatorname{sgn}\gamma \cdot (\sigma \times \tau)\circ [(e_{x(0)},e_{y(0)}), (e_{x(1)},e_{y(1)}), \dots, (e_{x(p+q)},e_{y(p+q)})]\] <p>其中\(\mathscr{P}(p,q)\)表示\(p\)列\(q\)行表格中的所有道路构成的集合。我们在这里不会严格证明这是一个单纯形剖分，只会给出一个直观的解释。</p> <p>比如我们来看道路：</p> \[\gamma_0:(0,0)\to (1,0)\to (2,0) \to \cdots \to (p,0) \to (p,1)\to \cdots \to (p,q)\] <p>这个道路给出的\(p+q\)维单形有\(p+q-1\)个面落在柱体\(\Delta^p \times \Delta^q\)的边界上，只有一个不在柱体的表面：</p> \[[(e_0,e_0),(e_1,e_0),\dots, (e_{p-1},e_{0}), (e_{p},e_1),(e_{p},e_2),\dots, (e_p,e_q)]\] <p>这个面实际上对应着\(\gamma_0\)在\((p,0)\)处的唯一一个“拐角”。为了消去这个面，我们将这个拐角“翻折”一下，得到新的路径\(\gamma_1\)：</p> \[\begin{array}{cccc|} &amp;&amp;&amp; \uparrow \\ &amp; (p-1,1) &amp; &amp; (p,1) \\ &amp;&amp;&amp; \uparrow \\ \rightarrow &amp; (p-1,0) &amp; \rightarrow &amp; (p,0)\\ \hline \end{array} \leadsto \begin{array}{cccc|} &amp;&amp;&amp; \uparrow \\ &amp; (p-1,1) &amp; \rightarrow &amp; (p,1) \\ &amp; \uparrow &amp;&amp;\\ \rightarrow &amp; (p-1,0) &amp;&amp; (p,0)\\ \hline \end{array}\] <p>为了让这个面的系数变为\(0\)，我们还需要给\(\gamma_1\)乘上一个负号（这时\(\gamma_1\)前的符号正好是\(\operatorname{sgn}\gamma_1\)）。</p> <p>但\(\gamma_1\)又会给出两个不在柱体边界上的面，这两个面正好对应\(\gamma_1\)在\((p-1,0)\)和\((p,1)\)处的两个拐角，所以为了消去这两个面，我们要将\(\gamma_1\)的两个“拐角”分别“翻折”，得到两条道路\(\gamma_2, \gamma_3\). 这时\(\gamma_2,\gamma_3\)前的符号会与\(\gamma_1\)的符号相反，所以它们的符号恰好也是\(\operatorname{sgn}\gamma_2\)和\(\operatorname{sgn}\gamma_3\).</p> <p>因为\(\gamma_2,\gamma_3\)也会有“拐角”，为了消去它们的拐角，我们需要再减去三条路径（这里有个微妙的地方是：有一条路径会同时抵消掉两个面，所以这条路径对应的系数仍然是\(\pm 1\)）。如此反复，我们就可以得到这一小节开头的单形剖分\(m(\sigma, \tau)\).</p> <h2 id="4性质与推论">4.性质与推论</h2> <p>对奇异单形的乘积有了单形剖分\(m\)之后，我们很容易将\(m\)延拓到奇异链的乘积上，得到：</p> \[m\colon S_p(X)\otimes S_q(Y) \longrightarrow S_{p+q}(X\times Y)\] <p>我们进一步给出单形剖分\(m\)的性质。</p> <p>首先很容易想到的是，两个标准单形\(\Delta^p, \Delta^q\)的乘积的边界是</p> \[(\partial \Delta^p)\times \Delta^q + (-1)^p \Delta^p \times (\partial\Delta^q)\] <p>而从上一节最后的论述可以看出来，单形剖分不改变乘积的边界，所以\(m(\sigma^{p},\tau^{q})\)的边界也是柱体\(\Delta^p\times\Delta^q\)的边界，也就是有：</p> \[\partial m(\sigma^p \otimes \tau^q) = m\bigl((\partial \sigma^p) \otimes \tau^q\bigr) + (-1)^{p}m\bigl(\sigma^p\otimes(\partial \tau^q)\bigr)\] <p>我们定义\(S_*(X),S_*(Y)\)的乘积复形为</p> \[\left(S_*(X)\otimes S_*(Y)\right)_{r} = \bigoplus_{p+q=r}S_p(X) \otimes S_q(Y)\] <p>其上的边缘算子为</p> \[\partial^{\otimes}\colon \sigma^p \otimes \tau^q \longmapsto (\partial \sigma^p) \otimes \tau^q + (-1)^{p}\sigma^p\otimes(\partial \tau^q)\] <p>另外很容易注意到的是，\(m\)是自然的，也就是，如果将\(S_{*}(\cdot)\otimes S_{*}(\cdot)\)与\(S_{*}(\cdot \times \cdot)\)视作两个函子，那么\(m\)实际上给出了它们之间的一个自然变换。</p> <p>那么这时候我们就知道：</p> <blockquote> <p><strong>命题</strong>：我们定义的单形剖分</p> \[m: S_*(X)\otimes S_*(Y) \rightarrow S_*(X\times Y)\] <p>是链映射，进而其诱导了同态：</p> \[m_*\colon H_r(S_*(X)\otimes S_*(Y)) \longrightarrow H_r(X \times Y).\] </blockquote> <p>如果使用一些同调代数的技术（比如谱序列），可以算出：</p> \[\begin{aligned} H_r(S_*(X)\otimes S_*(Y)) &amp; \sim \bigoplus_{p+q=r} H_{p}(X; H_q(Y)) \\ &amp; \sim \bigoplus_{p+q=r} H_{q}(Y; H_p(X)) \\ \end{aligned}\] <blockquote> <p><strong>推论</strong>：我们有自然的同态：</p> \[\begin{gathered} \bigoplus_{p+q=r} H_{p}(X; H_q(Y)) \longrightarrow H_r(X \times Y) \\ \bigoplus_{p+q=r} H_{q}(Y; H_p(X)) \longrightarrow H_r(X \times Y) \end{gathered}\] </blockquote> <p>在很多时候，上面的两个同构会给出一个同态，在此我们不讨论这一话题。</p> <h2 id="附录使用计算机计算低维奇异单形乘积的单形剖分">附录：使用计算机计算低维奇异单形乘积的单形剖分</h2> <p>在给出\(\sigma,\tau\)的具体维数的时候，可以使用计算机验证我们定义的\(m\)确为链映射。在此我们给出Python代码。</p> <pre><code class="language-Python">def select(n,p):
    '''An assistant function which return all the q-element subsets of [n] in the form: list(0 or 1). This can be further used to describe all the paths needed.'''
    if n&lt;=0 or p&lt;0 or n&lt;p:
        return []
    if p == 0:
        return [[0]*n]
    if n == p:
        return [[1,]*n]
    result = []
    l1 = select(n-1,p-1)
    for i in l1:
        i.append(1)
        result.append(i)
    l2 = select(n-1,p)
    for i in l2:
        i.append(0)
        result.append(i)
    return result

def path_generator(p:tuple,q:tuple)-&gt;list:
    '''generate the path needed to describe the simplex decomposition of product of 2 chains.'''
    r = len(p)+len(q)-2
    y = len(q)-1
    proto_path = select(r,len(q)-1)
    all_path = []
    for i in proto_path:
        path = []
        x_axis = 0
        y_axis = 0
        path_index = (-1)**(r*y+y*(y-1)//2)
        path.append((p[x_axis],q[y_axis]))
        for number_of_step in range(1,len(i)+1):
            x_axis += 1-i[number_of_step-1]
            y_axis += i[number_of_step-1]
            path.append((p[x_axis],q[y_axis]))
            path_index *= (-1)**(number_of_step*i[number_of_step-1])
        all_path.append((tuple(path),path_index))
    return all_path


class chain:
    '''class of (integer-coefficient simplicial) chain complexes'''

    def __init__(self, chains:dict =dict()):
        '''chains{simplex: coefficient} is a dictation record the simplexes and its coefficients in the chain.'''
        chains_keys = list(chains.keys())
        for i in chains_keys:
            if chains[i] == 0:
                chains.pop(i) # remove empty elements
        self.cells = chains
        return

    def __repr__(self):
        '''represent a chain as sum of "coefficient*simplex".'''
        if self.cells:
            return ' + '.join([str(self.cells[i])+str(i) for i in sorted(self.cells.keys())])
        else:
            return "0"

    def __add__(self, o):
        '''addition of chains.'''
        sum_chain = dict()
        for i in self.cells:
            sum_chain[i] = self.cells[i]
        assert type(o)==chain
        for j in o.cells:
            if j in sum_chain.keys():
                sum_chain[j]+=o.cells[j]
            else:
                sum_chain[j] = o.cells[j]
        return chain(sum_chain)

    def __sub__(self, o):
        sum_chain = dict()
        for i in self.cells:
            sum_chain[i] = self.cells[i]
        assert type(o)==chain
        for j in o.cells:
            if j in sum_chain.keys():
                sum_chain[j]-=o.cells[j]
            else:
                sum_chain[j] = -o.cells[j]
        return chain(sum_chain)

    def __mul__(self, o):
        '''Return the simplicial decomposition of Cartesian product of 2 chains.'''
        if type(o) == int or type(o) == float:
            for i in self.cells:
                self.cells[i] *= o
            return self
        else:
            d = dict()
            for i in self.cells:
                for j in o.cells:
                    for path in path_generator(i, j):
                        cell = path[0]
                        cell_index = path[1]
                        if cell in d.keys():
                            d[cell] += cell_index * self.cells[i]*o.cells[j]
                        else:
                            d[cell] = cell_index * self.cells[i]*o.cells[j]
            return chain(d)

    def partial(self):
        '''The boundary operator on chain complex.'''
        result = chain()
        for i in self.cells:
            d = dict()
            for j in range(len(i)):
                d[i[:j]+i[j+1:]] = (-1)**j*self.cells[i]
            result = result + chain(d)
        return result

if __name__ == "__main__":
    for p in range(1, 7):
        l = []
        for q in range(1,p+1):
            s1=tuple(i for i in range(p+1))
            s2=tuple(i for i in range(q+1))
            c1 = chain({s1:1})
            c2 = chain({s2:1})
            c3=(c1*c2).partial()
            c4=c1.partial()*c2 + c1*(c2.partial())*(-1)**p
            l.append(c3-c4)
        print(l)
</code></pre>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[Construct a concrete simplex decomposition of product of singular simplexes with an intuitive proof.]]></summary></entry></feed>